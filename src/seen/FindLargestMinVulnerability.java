package seen;

import java.util.Collections;
import java.util.List;
import java.util.PriorityQueue;

public class FindLargestMinVulnerability {
    /**
     * the developers of hackworld want to secure a database system consisting of n data servers.
     * the vulnerability of the ith server is represented by server[i].
     * an upgrade can be done on any particular server to reduce its vulnerability by 1 unt.
     * given the vulnerabilities of the servers represented by the array server,
     * find the maximum possible vulnerability of the smallest element in the final vulnerabilities of the servers
     * after performing exactly k upgrades.
     * consider  server = [3,4,5] and k = 4.
     *  Considersing 1-based indexing, te following upgrades can be performed:
     * 1 select server[1] and subtract 1 from it to obtain arr = [2,4,5]
     * 2.select server[2] and subtract 1 from it to obtain arr = [2,3,5,]
     * 3. select server[3] and subtract 1 from it to obtain arr = [2,3,4]
     * 4. select server[3] and subtract 1 from it to obtain arr = [2,3,3]
     * return 2 the smaleest vulnerability in the final array.
     * 数组中可能有负数， k可能是0 是0的话return-1；
     */
    public static long findLargestMinVulnerability(List<Integer> arr, long k) {
        List<Integer> positiveSorted = arr.stream().filter(n->n>0).sorted().toList();
        if(k == 0 || positiveSorted.isEmpty()){
            return -1;
        }
        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());
        for(int a : positiveSorted){
            if(k > 0){
                max.add(a - 1);
                k--;
            }else {
                break;
            }
        }
        if(k == 0 && !max.isEmpty()){
            while(!max.isEmpty()){
                if(max.size() ==1){
                    return max.poll();
                }
                max.poll();
            }
        }
        while(k > 0){
            int cur ;
            if(!max.isEmpty())
                cur = max.poll();
            else
                return -1;
            if (cur - 1 != 0) {
                max.add(cur - 1);
            }
            k--;
        }
        if(max.isEmpty()) {
            return 0;
        } else{
            while(!max.isEmpty()){
                if(max.size() == 1){
                    return max.poll();
                }
                max.poll();
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        // some cases I did not cover
        List<Integer> arr = List.of(3,4,5);
        System.out.println(findLargestMinVulnerability(arr,4));
    }
}
